---
title: swift中async/await工作原理
date: 2025-03-22 22:30:17
tags: [swift编程,异步编程]
---




# swift 中async/await 工作原理

在 Swift 5.5 中引入的 async/await 是 Swift Concurrency 模型的核心部分，它让开发者可以用类似同步代码的方式编写异步逻辑，同时又能充分利用并发优势。下面是其主要工作原理和关键概念：


### 1. 编译器转换为状态机

<!--more-->
- **语法糖**：当你在一个标记为 async 的函数中使用 await 时，编译器会将这个函数转换为一个状态机。这种转换方式让函数可以在等待异步操作时暂停，并在操作完成后恢复继续执行，就像在多线程环境中挂起和恢复任务一样。
- **状态保存**：在遇到 await 时，函数的当前状态（包括局部变量、执行位置等）会被保存下来，待异步操作完成后，状态机会恢复执行，这就避免了回调地狱，使代码更清晰。

### 2. 任务（Task）和并发执行


- **任务封装**：每个异步函数可以视为一个独立的任务。你可以显式创建任务（例如使用 Task { ... }）来启动异步操作。
- **调度器**：Swift 的运行时会根据当前系统的负载和任务的优先级，在可用线程上调度这些任务。调度器决定任务何时执行，以及如何高效利用系统资源。
- **结构化并发**：Swift 强调任务之间的结构化关系。例如，通过 TaskGroup 你可以启动一组相关联的任务，并等待所有任务完成。这种结构化并发可以帮助管理任务的生命周期，并自动处理错误传播。

### 3. 协程和继续（Continuation）


- **协程（Coroutines）**：异步函数本质上是协程，允许在执行过程中暂停和恢复。await 会挂起当前协程，释放执行线程，使其他任务可以运行，从而提高资源利用率。
- **继续（Continuation）**：当被等待的异步操作完成时，Swift 会恢复之前挂起的协程。这个过程类似于将工作“续接”到合适的点，继续处理后续逻辑。

### 4. 错误处理和取消


- **错误传播**：async/await 支持与传统的错误处理（try/catch）无缝结合。如果异步操作失败，可以抛出错误，并在调用处捕获处理。
- **任务取消**：Swift Concurrency 允许任务在需要时被取消，取消信号会被传播给所有相关的子任务，确保任务能够在适当的时候终止，避免不必要的资源占用。

### 总结


Swift 的 async/await 工作原理依赖于编译器将异步函数转换为状态机，通过任务和调度器管理并发执行。它利用协程暂停和恢复机制，以及结构化并发的思想，使得编写、调试和维护异步代码变得更加直观和高效。这一机制在提供性能优势的同时，也确保了代码的可读性和安全性。


在 Swift 中，`async/await` 是用于处理异步任务的一种简洁和高效的方式，通常用来简化异步编程和避免回调地狱（callback hell）。它是基于协程（coroutines）的概念，允许以同步的方式书写异步代码。这里是其工作原理的简要说明：


### 1. async 关键字


- 当一个函数被标记为 async 时，它表示这个函数是异步的，可能会进行长时间运行的操作（如网络请求、文件读取等），并且它的执行可能会被挂起（暂停），直到操作完成。
- async 函数不会立即返回结果，而是返回一个“未来的值”或者说是一个“任务（Task）”，它会在未来某个时刻完成。

### 2. await 关键字


- await 用于等待一个 async 函数的执行结果，它会暂停当前的函数，直到异步操作完成，接着继续执行后面的代码。
- await 只能在 async 函数内部使用。

### 3. 异步任务的调度


- 当你调用一个 async 函数并使用 await 时，函数会在后台线程中执行异步任务。它会“挂起”当前线程（不阻塞主线程），直到任务完成。挂起期间，线程可以去执行其他的任务。
- 这种挂起和恢复的机制是通过 Swift 的“任务（Task）”和“调度器（Scheduler）”来实现的，任务会被调度到合适的线程上继续执行。

### 4. 错误处理


- async 函数可以抛出错误，使用 throw 来表示错误。与同步函数不同，你可以用 try await 来调用一个可能抛出错误的 async 函数，并且必须处理这个错误。

### 示例代码


```swift
import Foundation

// 定义一个异步函数
func fetchData() async -&gt; String {
    // 模拟异步操作
    await Task.sleep(2 * 1_000_000_000) // 等待2秒
    return "数据获取成功"
}

// 调用异步函数
func performTask() async {
    let result = await fetchData() // 使用 await 等待 fetchData 完成
    print(result)
}

// 在主线程执行异步任务
Task {
    await performTask() // 启动异步任务
}
```


### 工作流程：


1. fetchData() 是一个异步函数，表示它会执行异步操作。在这个例子中，使用 Task.sleep 模拟了一个 2 秒的延时操作。
2. performTask() 中使用 await fetchData() 来调用异步函数，并等待其返回结果。
3. 使用 Task {} 启动异步任务，在主线程中执行 performTask()。

### 总结：


- async/await 提供了一个非常简洁的方式来处理异步代码，避免了传统的回调函数（callback）的层层嵌套。
- 它通过“任务”和“调度”的机制，让异步代码的书写和理解都变得更直观。