<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=PingFang SC:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","Muse | Mist":320,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="swift ui属性包裹器 在 SwiftUI 中，属性包装器（Property Wrapper）是一种用于封装和管理属性的特殊结构。它允许你对属性的读写操作进行封装，加入额外的逻辑，例如观察属性变化、提供默认值或进行数据存储等。 通常，在 SwiftUI 中，最常见的属性包装器有： 1. @State">
<meta property="og:type" content="article">
<meta property="og:title" content="swiftui属性包裹器">
<meta property="og:url" content="http://example.com/2025/03/02/swiftui%E5%B1%9E%E6%80%A7%E5%8C%85%E8%A3%B9%E5%99%A8/index.html">
<meta property="og:site_name" content="Yi&#39;s Lab">
<meta property="og:description" content="swift ui属性包裹器 在 SwiftUI 中，属性包装器（Property Wrapper）是一种用于封装和管理属性的特殊结构。它允许你对属性的读写操作进行封装，加入额外的逻辑，例如观察属性变化、提供默认值或进行数据存储等。 通常，在 SwiftUI 中，最常见的属性包装器有： 1. @State">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-03-02T04:07:41.000Z">
<meta property="article:modified_time" content="2025-09-01T08:36:04.792Z">
<meta property="article:author" content="YiDa">
<meta property="article:tag" content="swift编程">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2025/03/02/swiftui%E5%B1%9E%E6%80%A7%E5%8C%85%E8%A3%B9%E5%99%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>swiftui属性包裹器 | Yi's Lab</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Yi's Lab</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">You Find Your Own Tree.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section">首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section">关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section">标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section">分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section">归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger">搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/zhangyida-lab" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/03/02/swiftui%E5%B1%9E%E6%80%A7%E5%8C%85%E8%A3%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="YiDa">
      <meta itemprop="description" content="自古人生于世，须有一技之能；我辈既务斯业，便当专心用功；以后名扬四海，根据即在年轻。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yi's Lab">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          swiftui属性包裹器
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-03-02 13:07:41" itemprop="dateCreated datePublished" datetime="2025-03-02T13:07:41+09:00">2025-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-09-01 17:36:04" itemprop="dateModified" datetime="2025-09-01T17:36:04+09:00">2025-09-01</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="swift-ui属性包裹器"><a href="#swift-ui属性包裹器" class="headerlink" title="swift ui属性包裹器"></a>swift ui属性包裹器</h1><p> 在 SwiftUI 中，<strong>属性包装器</strong>（Property Wrapper）是一种用于封装和管理属性的特殊结构。它允许你对属性的读写操作进行封装，加入额外的逻辑，例如观察属性变化、提供默认值或进行数据存储等。</p>
<p>通常，在 SwiftUI 中，最常见的属性包装器有：</p>
<h3 id="1-State"><a href="#1-State" class="headerlink" title="1. @State"></a>1. <strong>@State</strong></h3><span id="more"></span>
<ul>
<li>用来在视图内部管理和持久化数据。当视图的状态发生改变时，视图会自动重新渲染。</li>
<li>例如：@State var counter: Int &#x3D; 0。</li>
</ul>
<h3 id="2-Binding"><a href="#2-Binding" class="headerlink" title="2. @Binding"></a>2. <strong>@Binding</strong></h3><ul>
<li>用于将父视图的状态绑定到子视图。它允许子视图修改父视图的数据。</li>
<li>例如：@Binding var isSwitchOn: Bool。</li>
</ul>
<h3 id="3-ObservedObject"><a href="#3-ObservedObject" class="headerlink" title="3. @ObservedObject"></a>3. <strong>@ObservedObject</strong></h3><ul>
<li>用于观察一个外部的对象，这个对象需要遵循 ObservableObject 协议，当它的属性变化时，视图会自动更新。</li>
<li>例如：@ObservedObject var viewModel: MyViewModel。</li>
</ul>
<h3 id="4-Environment"><a href="#4-Environment" class="headerlink" title="4. @Environment"></a>4. <strong>@Environment</strong></h3><ul>
<li>用来访问环境变量，这些环境变量通常由系统或父视图提供，可以在多个视图中共享。例如，访问设备的语言、当前主题等。</li>
<li>例如：@Environment(.colorScheme) var colorScheme。</li>
</ul>
<h3 id="5-EnvironmentObject"><a href="#5-EnvironmentObject" class="headerlink" title="5. @EnvironmentObject"></a>5. <strong>@EnvironmentObject</strong></h3><ul>
<li>类似于 @ObservedObject，但它是跨视图共享的，用来访问一个在环境中共享的数据模型。你必须在父视图中通过 .environmentObject() 注入这个对象。</li>
<li>例如：@EnvironmentObject var userSettings: UserSettings。</li>
</ul>
<h3 id="6-Published"><a href="#6-Published" class="headerlink" title="6. @Published"></a>6. <strong>@Published</strong></h3><ul>
<li>用于标记一个 ObservableObject 中的属性，表示这个属性的变化应该触发视图的更新。</li>
<li>例如：@Published var name: String。</li>
</ul>
<h3 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserSettings</span>: <span class="title class_">ObservableObject</span> &#123;</span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> username: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> isLoggedIn <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="meta">@ObservedObject</span> <span class="keyword">var</span> settings <span class="operator">=</span> <span class="type">UserSettings</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> isLoggedIn &#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;Welcome, <span class="subst">\(settings.username)</span>&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">Button</span>(<span class="string">&quot;Log In&quot;</span>) &#123;</span><br><span class="line">                    isLoggedIn.toggle()</span><br><span class="line">                    settings.username <span class="operator">=</span> <span class="string">&quot;User123&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li>@State 用来管理登录状态。</li>
<li>@ObservedObject 用来观察 UserSettings 对象，更新视图时自动反映数据变化。</li>
<li>@Published 则用于在 UserSettings 类中的 username 属性上，以便视图自动刷新。<br>总结来说，SwiftUI 的属性包装器通过简化状态管理和视图更新，让你能更轻松地处理 UI 中的动态数据。</li>
</ul>
<h1 id="用户问题"><a href="#用户问题" class="headerlink" title="用户问题"></a>用户问题</h1><p> 可以把上述代码再详细的给我解释下吗 </p>
<p> 当然可以！让我们更详细地分析这个代码示例。</p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserSettings</span>: <span class="title class_">ObservableObject</span> &#123;</span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> username: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>UserSettings 类</strong>：</li>
</ol>
<ul>
<li>这个类遵循了 ObservableObject 协议，意味着它可以作为一个对象，被 SwiftUI 视图观察。当这个类中的某个属性发生变化时，相关的视图会自动重新渲染。</li>
<li>类中的 username 属性是用 @Published 包裹的。这意味着，任何修改 username 的值时，UserSettings 会通知观察它的视图更新。简单来说，@Published 就是一个发布属性变化的信号器。<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> isLoggedIn <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="meta">@ObservedObject</span> <span class="keyword">var</span> settings <span class="operator">=</span> <span class="type">UserSettings</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> isLoggedIn &#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;Welcome, <span class="subst">\(settings.username)</span>&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">Button</span>(<span class="string">&quot;Log In&quot;</span>) &#123;</span><br><span class="line">                    isLoggedIn.toggle()</span><br><span class="line">                    settings.username <span class="operator">=</span> <span class="string">&quot;User123&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li><strong>ContentView 结构体</strong>：</li>
</ol>
<ul>
<li>ContentView 是一个 SwiftUI 视图，它遵循了 View 协议，表示它是一个可以渲染 UI 的视图。</li>
</ul>
<ol start="2">
<li><strong>@State 属性包装器</strong>：</li>
</ol>
<ul>
<li>@State 用于在视图内管理本地状态。isLoggedIn 表示用户是否已经登录。它是一个布尔值，用来控制视图中显示的内容。</li>
<li>private var isLoggedIn &#x3D; false：表示默认情况下，用户没有登录。因为 @State 是局部状态，只有 ContentView 内部能够访问和修改它。</li>
<li>当 isLoggedIn 状态改变时，视图会自动刷新。比如，点击登录按钮时，isLoggedIn.toggle() 会反转其值，触发视图更新。</li>
</ul>
<ol start="3">
<li><strong>@ObservedObject 属性包装器</strong>：</li>
</ol>
<ul>
<li>@ObservedObject 用于监听和观察一个符合 ObservableObject 协议的对象。在这个例子中，我们观察的是 settings 对象，它是 UserSettings 类型。</li>
<li>通过 @ObservedObject 包裹的对象可以跨视图进行共享，并且一旦对象的属性发生变化（例如 username），所有引用这个对象的视图都会自动更新。</li>
<li>var settings &#x3D; UserSettings()：我们在视图中创建了一个 UserSettings 的实例，SwiftUI 会监听它的变化。</li>
</ul>
<ol start="4">
<li><strong>VStack 和 if 判断语句</strong>：</li>
</ol>
<ul>
<li>VStack 是 SwiftUI 中用来垂直排列视图元素的容器。它会将内部的视图按顺序排列。</li>
<li>视图的显示内容是根据 isLoggedIn 的值来控制的：如果 isLoggedIn 为 true，显示一段欢迎文本，显示 settings.username 的值。如果 isLoggedIn 为 false，显示一个登录按钮。当用户点击按钮时，isLoggedIn 被切换为 true，并且 settings.username 被设置为 “User123”。</li>
</ul>
<ol start="5">
<li><strong>Button(“Log In”) 按钮</strong>：</li>
</ol>
<ul>
<li>当用户点击登录按钮时，按钮的操作会被触发：isLoggedIn.toggle() 和 settings.username &#x3D; “User123”。isLoggedIn.toggle() 会将 isLoggedIn 状态反转，如果当前为 false，就变为 true，反之亦然。settings.username &#x3D; “User123” 会修改 settings 对象中的 username 属性。由于 username 使用了 @Published 包裹，当它的值改变时，SwiftUI 会通知所有观察 settings 的视图更新，从而刷新视图。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>@State</strong>：用来管理视图内部的本地状态，在此例中用来控制是否显示登录界面。</li>
<li><strong>@ObservedObject</strong>：用来观察外部对象的变化，这里观察的是 UserSettings 对象，包含用户的登录信息。</li>
<li><strong>@Published</strong>：用来标记 UserSettings 中的 username 属性，确保当其值发生变化时，相关视图会自动刷新。<br><strong>整体流程</strong>：</li>
</ul>
<ol>
<li>初始时，isLoggedIn 为 false，视图显示登录按钮。</li>
<li>用户点击按钮后，isLoggedIn 被切换为 true，username 设置为 “User123”。</li>
<li>@Published 使得 username 的变化会自动通知视图更新，因此文本显示了 “Welcome, User123”。</li>
<li>由于 @ObservedObject 使得视图观察 settings 对象的变化，username 的修改会触发视图重新渲染。<br>希望这更详细的解析能够帮助你理解 SwiftUI 中属性包装器的使用！</li>
</ol>
<h1 id="跨视图进行共享的示例代码"><a href="#跨视图进行共享的示例代码" class="headerlink" title="跨视图进行共享的示例代码"></a>跨视图进行共享的示例代码</h1><p> 下面是一个跨视图共享数据的示例，展示了如何使用 <code>@EnvironmentObject</code> 在多个视图之间共享数据。</p>
<p>在这个示例中，我们会创建一个 <code>UserSettings</code> 类，它遵循 <code>ObservableObject</code> 协议，并使用 <code>@Published</code> 来标记需要在视图间共享的属性。然后，通过 <code>@EnvironmentObject</code> 让不同的视图能够访问和修改这些共享的数据。</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>创建一个共享的数据模型 UserSettings。</li>
<li>在父视图中提供这个共享数据。</li>
<li>在子视图中通过 @EnvironmentObject 来访问和修改共享数据。</li>
</ol>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><h4 id="1-创建-UserSettings-数据模型"><a href="#1-创建-UserSettings-数据模型" class="headerlink" title="1. 创建 UserSettings 数据模型"></a>1. 创建 UserSettings 数据模型</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据模型，遵循 ObservableObject 协议</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserSettings</span>: <span class="title class_">ObservableObject</span> &#123;</span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> username: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-父视图：注入共享数据"><a href="#2-父视图：注入共享数据" class="headerlink" title="2. 父视图：注入共享数据"></a>2. 父视图：注入共享数据</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ParentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 UserSettings 实例</span></span><br><span class="line">    <span class="meta">@StateObject</span> <span class="keyword">var</span> settings <span class="operator">=</span> <span class="type">UserSettings</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="comment">// 通过 environmentObject 注入共享数据</span></span><br><span class="line">            <span class="type">ChildView</span>()</span><br><span class="line">                .environmentObject(settings)  <span class="comment">// 共享数据注入到子视图中</span></span><br><span class="line"></span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Parent: <span class="subst">\(settings.username)</span>&quot;</span>)  <span class="comment">// 父视图显示共享的数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-子视图：使用共享数据"><a href="#3-子视图：使用共享数据" class="headerlink" title="3. 子视图：使用共享数据"></a>3. 子视图：使用共享数据</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ChildView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="comment">// 通过 environmentObject 来获取父视图传递的共享数据</span></span><br><span class="line">    <span class="meta">@EnvironmentObject</span> <span class="keyword">var</span> settings: <span class="type">UserSettings</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Child: <span class="subst">\(settings.username)</span>&quot;</span>)  <span class="comment">// 子视图显示共享的数据</span></span><br><span class="line"></span><br><span class="line">            <span class="type">Button</span>(<span class="string">&quot;Change Username&quot;</span>) &#123;</span><br><span class="line">                settings.username <span class="operator">=</span> <span class="string">&quot;NewUser&quot;</span>  <span class="comment">// 修改共享数据</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-启动视图"><a href="#4-启动视图" class="headerlink" title="4. 启动视图"></a>4. 启动视图</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@main</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyApp</span>: <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">Scene</span> &#123;</span><br><span class="line">        <span class="type">WindowGroup</span> &#123;</span><br><span class="line">            <span class="type">ParentView</span>()  <span class="comment">// 启动父视图</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><ol>
<li><strong>UserSettings 类</strong>：</li>
</ol>
<ul>
<li>这个类遵循了 ObservableObject 协议，并通过 @Published 将 username 标记为可发布的属性。这样，当 username 改变时，所有观察它的视图会自动刷新。</li>
</ul>
<ol start="2">
<li><strong>ParentView</strong>：</li>
</ol>
<ul>
<li>@StateObject 用来创建一个 UserSettings 的实例。StateObject 用于在视图生命周期内创建一个对象并保持其状态。</li>
<li>使用 .environmentObject(settings) 将 settings 共享到子视图中。这样，所有子视图都能访问并修改 settings 中的数据。</li>
</ul>
<ol start="3">
<li><strong>ChildView</strong>：</li>
</ol>
<ul>
<li>@EnvironmentObject 用于在子视图中获取共享的 UserSettings 实例。在这个例子中，settings.username 会显示在子视图中，并且子视图可以修改它。当 username 修改时，所有使用该数据的视图都会更新。</li>
</ul>
<ol start="4">
<li><strong>MyApp</strong>：</li>
</ol>
<ul>
<li>作为应用程序的入口，我们将 ParentView 设置为根视图。</li>
</ul>
<h3 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h3><ul>
<li>初始时，username 在 UserSettings 中是空字符串。</li>
<li>ParentView 显示共享的 username，并将 UserSettings 通过 .environmentObject() 注入到 ChildView 中。</li>
<li>ChildView 中有一个按钮，当点击时，它会修改 settings.username 的值。</li>
<li>修改后的 username 会反映在 ParentView 和 ChildView 中，因为它们都共享同一个 UserSettings 实例。</li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><strong>@StateObject</strong> 用于在父视图中创建一个对象实例，并管理它的生命周期。</li>
<li><strong>@EnvironmentObject</strong> 让子视图能够访问和修改父视图传递的共享数据对象。</li>
<li>当共享数据改变时，所有依赖于它的视图都会自动更新，保证了数据的一致性和视图的同步。<br>这样，<code>@EnvironmentObject</code> 就帮助我们轻松实现了跨视图的数据共享。</li>
</ul>
<h1 id="用户问题-1"><a href="#用户问题-1" class="headerlink" title="用户问题"></a>用户问题</h1><p> swiftui中一般的视图嵌套原则及注意事项 </p>
<p> 在 SwiftUI 中，视图嵌套是一种常见的设计模式，它允许你通过组合简单的视图组件来构建复杂的 UI。但为了确保代码的可维护性和性能，嵌套视图时有一些原则和注意事项需要遵循。</p>
<h3 id="1-简洁性和可复用性"><a href="#1-简洁性和可复用性" class="headerlink" title="1. 简洁性和可复用性"></a>1. <strong>简洁性和可复用性</strong></h3><ul>
<li><strong>嵌套要有目的性</strong>：每个视图的嵌套应该有明确的目的。例如，使用容器视图（如 VStack、HStack、ZStack）来组织内容，而不是随便嵌套。</li>
<li><strong>可复用性</strong>：将通用的视图组件提取为单独的视图，避免重复代码，提高复用性。例如，如果多个地方需要展示相同样式的按钮，可以将其提取成一个自定义按钮视图。<br><strong>示例</strong>：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomButton</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> action: () -&gt; <span class="type">Void</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(action: action) &#123;</span><br><span class="line">            <span class="type">Text</span>(title)</span><br><span class="line">                .padding()</span><br><span class="line">                .background(<span class="type">Color</span>.blue)</span><br><span class="line">                .foregroundColor(.white)</span><br><span class="line">                .cornerRadius(<span class="number">10</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-视图嵌套深度控制"><a href="#2-视图嵌套深度控制" class="headerlink" title="2. 视图嵌套深度控制"></a>2. <strong>视图嵌套深度控制</strong></h3><ul>
<li><strong>避免过度嵌套</strong>：嵌套层级过深的视图可能会导致代码不易理解和维护，并且可能会影响性能。理想情况下，视图的嵌套层级应保持在合理范围内。</li>
<li><strong>合理拆分视图</strong>：如果发现视图嵌套过深，可以考虑将其拆分成多个更小的视图，这样不仅能提高可读性，还能方便测试和修改。<br><strong>示例</strong>：如果一个视图过于复杂，考虑将其拆分：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ProfileView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">ProfileHeaderView</span>()</span><br><span class="line">            <span class="type">ProfileContentView</span>()</span><br><span class="line">            <span class="type">ProfileFooterView</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-性能优化"><a href="#3-性能优化" class="headerlink" title="3. 性能优化"></a>3. <strong>性能优化</strong></h3><ul>
<li><strong>避免频繁的视图更新</strong>：视图嵌套时，要避免让整个视图层级都重新渲染，尤其是在高频率更新的情况下。可以使用 @State、@Binding、@ObservedObject 等属性包装器，限制视图更新的范围。</li>
<li><strong>使用 LazyVStack 和 LazyHStack</strong>：对于长列表的视图嵌套，使用 LazyVStack 或 LazyHStack 来避免加载所有子视图，提升性能。这些懒加载视图只会在需要时加载子视图。<br><strong>示例</strong>：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LazyListView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> items <span class="operator">=</span> <span class="type">Array</span>(<span class="number">1</span><span class="operator">...</span><span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ScrollView</span> &#123;</span><br><span class="line">            <span class="type">LazyVStack</span> &#123;</span><br><span class="line">                <span class="type">ForEach</span>(items, id: \.<span class="keyword">self</span>) &#123; item <span class="keyword">in</span></span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;Item <span class="subst">\(item)</span>&quot;</span>)</span><br><span class="line">                        .padding()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-布局和约束"><a href="#4-布局和约束" class="headerlink" title="4. 布局和约束"></a>4. <strong>布局和约束</strong></h3><ul>
<li><strong>避免硬编码的尺寸和布局</strong>：尽量避免为视图设置固定的尺寸，尤其是在自适应布局时。使用自动布局特性，如 Spacer()、padding()、frame(minWidth:idealWidth:maxWidth:) 等，来动态调整视图的大小。</li>
<li><strong>合适的视图对齐</strong>：使用 alignment 修饰符来确保子视图正确对齐。例如，VStack 和 HStack 提供了对齐选项，ZStack 提供了层叠排列的能力。<br><strong>示例</strong>：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">VStack</span>(alignment: .leading) &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;SwiftUI is amazing.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">.padding()</span><br></pre></td></tr></table></figure>

<h3 id="5-数据驱动的视图设计"><a href="#5-数据驱动的视图设计" class="headerlink" title="5. 数据驱动的视图设计"></a>5. <strong>数据驱动的视图设计</strong></h3><ul>
<li><strong>基于数据构建视图</strong>：SwiftUI 强调声明式 UI，视图应当根据数据状态自动更新。避免在视图中直接进行逻辑处理或进行复杂的视图判断。应当通过 @State、@Binding、@ObservedObject 和 @EnvironmentObject 来管理数据和视图的同步。<br><strong>示例</strong>：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> isLoggedIn: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> isLoggedIn &#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;Welcome Back!&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">Button</span>(<span class="string">&quot;Log In&quot;</span>) &#123;</span><br><span class="line">                    isLoggedIn.toggle()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-注意避免状态污染"><a href="#6-注意避免状态污染" class="headerlink" title="6. 注意避免状态污染"></a>6. <strong>注意避免状态污染</strong></h3><ul>
<li><strong>避免不必要的共享状态</strong>：不要将父视图的状态直接传递给多个子视图，尤其是在层级较深的嵌套视图中。对于多层嵌套的视图，可以使用 @EnvironmentObject 来避免将每个子视图都直接传递状态。</li>
<li><strong>尽量减少全局状态的依赖</strong>：过多的全局状态（如 @EnvironmentObject）可能会导致视图间的耦合度增高，从而影响可维护性。只有在多视图共享同一数据时，使用 @EnvironmentObject。</li>
</ul>
<h3 id="7-可读性和结构化"><a href="#7-可读性和结构化" class="headerlink" title="7. 可读性和结构化"></a>7. <strong>可读性和结构化</strong></h3><ul>
<li><strong>清晰的视图层级结构</strong>：嵌套的视图应该有清晰的结构，避免无意义的嵌套或过于复杂的层级。确保每个嵌套的视图都有明确的功能和目的。</li>
<li><strong>注释和命名</strong>：适当的注释和合理的命名能够让代码更加可读，特别是在视图嵌套较深时，清晰的命名可以帮助理解每个视图的作用。<br><strong>示例</strong>：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ProfileHeaderView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;User Name&quot;</span>)</span><br><span class="line">                .font(.title)</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Location&quot;</span>)</span><br><span class="line">                .font(.subheadline)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-使用视图修饰符"><a href="#8-使用视图修饰符" class="headerlink" title="8. 使用视图修饰符"></a>8. <strong>使用视图修饰符</strong></h3><ul>
<li><strong>减少冗余修饰符</strong>：尽量避免在多个层级的嵌套视图中重复相同的视图修饰符。可以将修饰符应用到较高层级的视图，而不是每个子视图。</li>
<li><strong>组合修饰符</strong>：可以使用 .modifier 来封装一组视图修饰符，避免重复代码。<br><strong>示例</strong>：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">RoundedButton</span>: <span class="title class_">ViewModifier</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">body</span>(<span class="params">content</span>: <span class="type">Content</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        content</span><br><span class="line">            .padding()</span><br><span class="line">            .background(<span class="type">Color</span>.blue)</span><br><span class="line">            .foregroundColor(.white)</span><br><span class="line">            .cornerRadius(<span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(<span class="string">&quot;Click Me&quot;</span>) &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Button clicked&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .modifier(<span class="type">RoundedButton</span>())  <span class="comment">// 使用自定义的修饰符</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>避免过度嵌套</strong>：嵌套层次过深会影响可读性和性能，尽量保持视图的层次清晰。</li>
<li><strong>优化性能</strong>：使用 LazyVStack 和 LazyHStack 来提升长列表的性能，避免不必要的重绘。</li>
<li><strong>数据驱动的视图设计</strong>：使用 SwiftUI 的状态和绑定机制，使视图自动响应数据变化。</li>
<li><strong>代码结构清晰</strong>：合理拆分视图和修饰符，保持代码简洁可读。<br>遵循这些原则和注意事项，能让你的 SwiftUI 视图更加高效、清晰和易于维护。</li>
</ul>
<h1 id="仔细解释一下-state"><a href="#仔细解释一下-state" class="headerlink" title="仔细解释一下@state"></a>仔细解释一下@state</h1><p> <code>@State</code> 是 SwiftUI 中用于管理视图状态的一种属性包装器。它允许视图持有和修改数据，并且当数据发生变化时，自动触发视图的重新渲染。<code>@State</code> 是在视图内部使用的，并且它的生命周期与视图的生命周期是绑定的。也就是说，当视图被销毁时，<code>@State</code> 管理的数据也会被销毁。</p>
<h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ol>
<li><strong>局部视图状态</strong>：</li>
</ol>
<ul>
<li>@State 用来声明视图内部的局部状态。它的作用是让某个视图或其子视图能够响应数据变化，并更新 UI。</li>
<li>只有在视图的范围内，@State 才能生效。它通常用于控制视图中的某些界面元素，如按钮的点击状态、文本框的输入值、开关的开启与关闭等。</li>
</ul>
<ol start="2">
<li><strong>触发视图更新</strong>：</li>
</ol>
<ul>
<li>使用 @State 的变量一旦发生变化，SwiftUI 会自动重新渲染这个视图。例如，按钮点击后改变一个 @State 变量的值，SwiftUI 会自动更新这个视图。</li>
</ul>
<ol start="3">
<li><strong>绑定到视图的值</strong>：</li>
</ol>
<ul>
<li>@State 声明的变量不仅在视图内使用，还可以通过 Binding 与其他视图进行交互，例如子视图可以通过 @Binding 传递父视图的 @State 数据。</li>
</ul>
<h3 id="State-的工作原理"><a href="#State-的工作原理" class="headerlink" title="@State 的工作原理"></a>@State 的工作原理</h3><p>当你为某个变量添加 <code>@State</code> 属性包装器时，SwiftUI 会自动为该变量提供存储机制和更新机制。你不需要手动创建存储或管理状态，SwiftUI 会在合适的时候自动处理这些。</p>
<h3 id="使用场景和示例"><a href="#使用场景和示例" class="headerlink" title="使用场景和示例"></a>使用场景和示例</h3><h4 id="1-按钮点击状态"><a href="#1-按钮点击状态" class="headerlink" title="1. 按钮点击状态"></a>1. <strong>按钮点击状态</strong></h4><p><code>@State</code> 可以用来管理按钮点击后的状态。例如，一个按钮用于切换文本显示内容。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> isPressed <span class="operator">=</span> <span class="literal">false</span>  <span class="comment">// 按钮状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(isPressed <span class="operator">?</span> <span class="string">&quot;按钮已点击&quot;</span> : <span class="string">&quot;按钮未点击&quot;</span>)</span><br><span class="line">                .padding()</span><br><span class="line">            </span><br><span class="line">            <span class="type">Button</span>(action: &#123;</span><br><span class="line">                isPressed.toggle()  <span class="comment">// 切换按钮状态</span></span><br><span class="line">            &#125;) &#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;点击我&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            .padding()</span><br><span class="line">            .background(<span class="type">Color</span>.blue)</span><br><span class="line">            .foregroundColor(.white)</span><br><span class="line">            .cornerRadius(<span class="number">10</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：</p>
<ul>
<li>@State private var isPressed &#x3D; false 声明了一个状态变量 isPressed，用来追踪按钮是否被点击。</li>
<li>每当按钮被点击，isPressed 的值会通过 isPressed.toggle() 改变，Text 视图会根据 isPressed 的状态自动更新。</li>
</ul>
<h4 id="2-文本框输入状态"><a href="#2-文本框输入状态" class="headerlink" title="2. 文本框输入状态"></a>2. <strong>文本框输入状态</strong></h4><p><code>@State</code> 也常用于获取文本框的输入值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> username <span class="operator">=</span> <span class="string">&quot;&quot;</span>  <span class="comment">// 存储文本框输入的内容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">TextField</span>(<span class="string">&quot;请输入用户名&quot;</span>, text: <span class="variable">$username</span>)</span><br><span class="line">                .padding()</span><br><span class="line">                .textFieldStyle(<span class="type">RoundedBorderTextFieldStyle</span>())</span><br><span class="line"></span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;欢迎，<span class="subst">\(username)</span>！&quot;</span>)</span><br><span class="line">                .padding()</span><br><span class="line">        &#125;</span><br><span class="line">        .padding()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：</p>
<ul>
<li>@State private var username &#x3D; “” 声明了一个 @State 变量来存储文本框的输入内容。</li>
<li>TextField 的 text 参数是通过 $username 绑定到 @State 变量的，这样文本框的内容就会同步到 username 变量，并且当 username 更新时，SwiftUI 会自动刷新 UI。</li>
<li>当用户输入新的用户名时，username 会被更新，并且下方的 Text 会显示新的用户名。</li>
</ul>
<h4 id="3-切换开关状态"><a href="#3-切换开关状态" class="headerlink" title="3. 切换开关状态"></a>3. <strong>切换开关状态</strong></h4><p>你也可以用 <code>@State</code> 来管理开关控件的状态。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> isOn <span class="operator">=</span> <span class="literal">false</span>  <span class="comment">// 控制开关状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Toggle</span>(isOn: <span class="variable">$isOn</span>) &#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;是否开启通知&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            .padding()</span><br><span class="line"></span><br><span class="line">            <span class="type">Text</span>(isOn <span class="operator">?</span> <span class="string">&quot;通知已开启&quot;</span> : <span class="string">&quot;通知已关闭&quot;</span>)</span><br><span class="line">                .padding()</span><br><span class="line">        &#125;</span><br><span class="line">        .padding()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：</p>
<ul>
<li>@State private var isOn &#x3D; false 声明了一个布尔类型的状态变量，用于控制开关的状态。</li>
<li>Toggle(isOn: $isOn) 创建了一个开关控件，它的值与 isOn 绑定。</li>
<li>Text 根据 isOn 的状态动态显示内容。当开关状态变化时，isOn 的值会发生变化，SwiftUI 会自动重新渲染 Text 视图。</li>
</ul>
<h3 id="State-的绑定与-Binding"><a href="#State-的绑定与-Binding" class="headerlink" title="@State 的绑定与 @Binding"></a>@State 的绑定与 @Binding</h3><ul>
<li><strong>绑定到父视图的状态</strong>：<br>如果你需要将 <code>@State</code> 数据传递给子视图，并允许子视图修改父视图的状态，你可以使用 <code>@Binding</code>。<strong>示例</strong>：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ParentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> isToggled <span class="operator">=</span> <span class="literal">false</span>  <span class="comment">// 父视图的状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ChildView</span>(isToggled: <span class="variable">$isToggled</span>)  <span class="comment">// 传递绑定</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ChildView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@Binding</span> <span class="keyword">var</span> isToggled: <span class="type">Bool</span>  <span class="comment">// 子视图接收绑定</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Toggle</span>(<span class="string">&quot;切换状态&quot;</span>, isOn: <span class="variable">$isToggled</span>)  <span class="comment">// 控制父视图的状态</span></span><br><span class="line">            .padding()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>解释</strong>：父视图 ParentView 使用 @State 创建了 isToggled 状态，并通过 $isToggled 将绑定传递给子视图 ChildView。在子视图 ChildView 中，@Binding 使得 isToggled 变量与父视图的状态绑定，这样子视图修改 isToggled 时，父视图的状态也会同步更新。</li>
</ul>
<h3 id="State-使用时的注意事项"><a href="#State-使用时的注意事项" class="headerlink" title="@State 使用时的注意事项"></a>@State 使用时的注意事项</h3><ol>
<li><strong>@State 的生命周期与视图绑定</strong>：</li>
</ol>
<ul>
<li>@State 变量的生命周期与视图的生命周期是绑定的。当视图被销毁时，@State 变量也会销毁。如果视图重新创建（例如，重新进入视图或切换 Tab 时），@State 变量的值会被重新初始化。</li>
</ul>
<ol start="2">
<li><strong>只能在视图内部使用</strong>：</li>
</ol>
<ul>
<li>@State 只能在视图内部使用，不能传递到外部视图或外部类中。如果你需要共享状态，可以使用 @ObservedObject、@EnvironmentObject 或 @Binding。</li>
</ul>
<ol start="3">
<li><strong>避免过度使用 @State</strong>：</li>
</ol>
<ul>
<li>过度使用 @State 可能导致视图之间的紧耦合。对于需要跨多个视图共享的状态，考虑使用 @ObservedObject 或 @EnvironmentObject。</li>
</ul>
<ol start="4">
<li><strong>只用于视图内部状态</strong>：</li>
</ol>
<ul>
<li>@State 应仅用于表示视图内部的状态。如果你需要管理更复杂或跨多个视图共享的数据，应考虑使用 @ObservedObject 或其他更合适的方式。</li>
</ul>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li>@State 是 SwiftUI 中用于管理局部视图状态的核心属性包装器。</li>
<li>它允许视图内部的数据变化触发视图的重新渲染，简化了 UI 的更新机制。</li>
<li>@State 只在视图的生命周期内有效，且只能在视图内使用。</li>
<li>如果需要跨视图共享状态，可以通过 @Binding、@ObservedObject 或 @EnvironmentObject 来实现。<br>希望这些解释能帮助你更好地理解 <code>@State</code> 的用法！如果有其他问题，欢迎继续提问。</li>
</ul>
<h1 id="binding-state-与observableobject-的应用场景区别"><a href="#binding-state-与observableobject-的应用场景区别" class="headerlink" title="binding state 与observableobject 的应用场景区别"></a>binding state 与observableobject 的应用场景区别</h1><p> binding state 与observableobject 的应用场景区别 </p>
<p> <code>@Binding</code>、<code>@State</code> 和 <code>@ObservedObject</code> 都是 SwiftUI 中用于管理和共享数据的属性包装器。它们在应用场景中有不同的适用性，理解它们之间的差异能帮助你更好地组织应用的数据流和视图更新。</p>
<h3 id="1-State-——-用于局部视图状态管理"><a href="#1-State-——-用于局部视图状态管理" class="headerlink" title="1. @State —— 用于局部视图状态管理"></a>1. <strong>@State</strong> —— 用于局部视图状态管理</h3><ul>
<li><strong>适用场景</strong>：@State 适用于管理 <strong>单一视图内部的局部状态</strong>，这种状态只对当前视图有意义。一般用于控制视图中的简单状态变化，如按钮的点击状态、文本框的输入值、开关的开启&#x2F;关闭状态等。该状态变量的生命周期与视图的生命周期是绑定的，当视图销毁时，@State 的值也会被销毁。</li>
<li><strong>应用实例</strong>：控制一个按钮的状态，或者管理一个表单输入字段的值。<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> isButtonPressed <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(action: &#123;</span><br><span class="line">            isButtonPressed.toggle()</span><br><span class="line">        &#125;) &#123;</span><br><span class="line">            <span class="type">Text</span>(isButtonPressed <span class="operator">?</span> <span class="string">&quot;按钮被按下&quot;</span> : <span class="string">&quot;按钮未按下&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>特点</strong>：@State 仅限于视图内部使用，不能跨视图共享状态。数据变化会触发视图更新，但这个状态不会被外部视图直接访问或修改。</li>
</ul>
<h3 id="2-Binding-——-用于在父视图与子视图间共享和双向绑定状态"><a href="#2-Binding-——-用于在父视图与子视图间共享和双向绑定状态" class="headerlink" title="2. @Binding —— 用于在父视图与子视图间共享和双向绑定状态"></a>2. <strong>@Binding</strong> —— 用于在父视图与子视图间共享和双向绑定状态</h3><ul>
<li><strong>适用场景</strong>：@Binding 用于在父视图和子视图之间传递和共享 <strong>双向绑定的状态</strong>。它通常用于父视图管理数据，而子视图能够访问并修改父视图中的 @State 数据。通过 @Binding，子视图可以直接修改父视图的状态，从而实现父视图和子视图的双向绑定。</li>
<li><strong>应用实例</strong>：子视图控制父视图的开关状态或更新文本字段的值。<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ParentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> isToggled <span class="operator">=</span> <span class="literal">false</span>  <span class="comment">// 父视图的状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ChildView</span>(isToggled: <span class="variable">$isToggled</span>)  <span class="comment">// 传递绑定</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ChildView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@Binding</span> <span class="keyword">var</span> isToggled: <span class="type">Bool</span>  <span class="comment">// 子视图接收父视图的绑定</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Toggle</span>(<span class="string">&quot;切换开关&quot;</span>, isOn: <span class="variable">$isToggled</span>)  <span class="comment">// 修改父视图的状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>特点</strong>：@Binding 只是一个 <strong>引用</strong>，它指向父视图的 @State 变量，因此子视图可以修改父视图的状态。@Binding 需要配合父视图的 @State 使用，通常通过 $ 前缀将父视图的状态传递给子视图。</li>
</ul>
<h3 id="3-ObservedObject-——-用于跨视图共享和观察数据模型"><a href="#3-ObservedObject-——-用于跨视图共享和观察数据模型" class="headerlink" title="3. @ObservedObject —— 用于跨视图共享和观察数据模型"></a>3. <strong>@ObservedObject</strong> —— 用于跨视图共享和观察数据模型</h3><ul>
<li><strong>适用场景</strong>：@ObservedObject 用于在视图中 <strong>观察和绑定外部数据模型</strong>。数据模型是遵循 ObservableObject 协议的类，通常用于管理跨多个视图共享的数据。它可以在多个视图间共享数据，而每当数据变化时，相关的视图都会自动更新。@ObservedObject 适用于 <strong>跨视图共享数据</strong>，并且该数据模型通常是由外部视图或外部对象创建和管理的，而非视图内部。</li>
<li><strong>应用实例</strong>：多个视图共享同一个数据源（例如用户设置、网络请求的结果等）。<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserSettings</span>: <span class="title class_">ObservableObject</span> &#123;</span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> username: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;Guest&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@ObservedObject</span> <span class="keyword">var</span> userSettings <span class="operator">=</span> <span class="type">UserSettings</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Hello, <span class="subst">\(userSettings.username)</span>&quot;</span>)</span><br><span class="line">            <span class="type">Button</span>(<span class="string">&quot;Change Username&quot;</span>) &#123;</span><br><span class="line">                userSettings.username <span class="operator">=</span> <span class="string">&quot;NewUser&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>特点</strong>：@ObservedObject 是 <strong>引用类型</strong>，它观察一个遵循 ObservableObject 协议的对象，当对象中的 @Published 属性发生变化时，相关视图会自动更新。适用于管理较为复杂或跨多个视图的数据状态。</li>
</ul>
<h3 id="State、-Binding-和-ObservedObject-的对比"><a href="#State、-Binding-和-ObservedObject-的对比" class="headerlink" title="@State、@Binding 和 @ObservedObject 的对比"></a>@State、@Binding 和 @ObservedObject 的对比</h3><table>
<thead>
<tr>
<th>特性</th>
<th>@State</th>
<th>@Binding</th>
<th>@ObservedObject</th>
</tr>
</thead>
<tbody><tr>
<td><strong>作用范围</strong></td>
<td>仅限于当前视图内部</td>
<td>父视图与子视图间双向绑定</td>
<td>跨视图共享和观察数据模型</td>
</tr>
<tr>
<td><strong>数据存储位置</strong></td>
<td>视图内部（局部状态）</td>
<td>绑定到父视图的 @State 数据</td>
<td>外部对象，通常是数据模型类</td>
</tr>
<tr>
<td><strong>数据更新方式</strong></td>
<td>本地修改数据会触发视图更新</td>
<td>子视图修改父视图的数据，双向绑定</td>
<td>数据模型更新时视图会自动更新</td>
</tr>
<tr>
<td><strong>使用方式</strong></td>
<td>用于管理局部视图状态</td>
<td>用于子视图与父视图之间的状态绑定</td>
<td>用于跨视图共享数据模型</td>
</tr>
<tr>
<td><strong>生命周期</strong></td>
<td>与视图生命周期一致</td>
<td>绑定到父视图的生命周期</td>
<td>数据模型在多个视图之间共享，生命周期独立于视图</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>简单的局部视图状态管理</td>
<td>父子视图间的双向数据绑定</td>
<td>需要跨视图共享和观察的数据模型</td>
</tr>
</tbody></table>
<h3 id="适用场景总结"><a href="#适用场景总结" class="headerlink" title="适用场景总结"></a>适用场景总结</h3><ul>
<li><strong>@State</strong>：适用于 <strong>局部状态</strong> 的管理，通常用在单个视图内部。视图的状态变量只有在当前视图的生命周期内有效。</li>
<li><strong>@Binding</strong>：用于 <strong>父视图与子视图</strong> 之间共享状态，特别是在父视图拥有状态，子视图需要访问和修改该状态时。通过 $ 符号将 @State 传递给子视图。</li>
<li><strong>@ObservedObject</strong>：适用于 <strong>跨多个视图共享和观察数据模型</strong>，用于管理更复杂的、全局的数据，数据模型遵循 ObservableObject 协议，适合需要在多个视图间共享并且保持同步的数据。</li>
</ul>
<h3 id="何时使用-State、-Binding-和-ObservedObject"><a href="#何时使用-State、-Binding-和-ObservedObject" class="headerlink" title="何时使用 @State、@Binding 和 @ObservedObject"></a>何时使用 @State、@Binding 和 @ObservedObject</h3><ul>
<li><strong>简单的视图状态管理</strong>：使用 @State，如按钮点击、开关状态等。</li>
<li><strong>父子视图之间的状态传递</strong>：使用 @Binding，如父视图传递一个 @State 状态给子视图。</li>
<li><strong>跨视图共享数据</strong>：使用 @ObservedObject，当数据需要在多个视图之间共享且可能由外部对象（如模型类）管理时。<br>希望这些解释能够帮助你理解这三者的区别和适用场景！如果你有更具体的场景或问题，欢迎继续提问。</li>
</ul>
<h1 id="uikit和swiftui的区别"><a href="#uikit和swiftui的区别" class="headerlink" title="uikit和swiftui的区别"></a>uikit和swiftui的区别</h1><p> uikit和swiftui的区别 </p>
<p> <code>UIKit</code> 和 <code>SwiftUI</code> 都是 Apple 用于开发 iOS、iPadOS、macOS 和其他平台的 UI 框架。它们各自有自己的特点、优缺点和适用场景。下面我会详细对比这两个框架的主要区别：</p>
<h3 id="1-开发方式：声明式-vs-命令式"><a href="#1-开发方式：声明式-vs-命令式" class="headerlink" title="1. 开发方式：声明式 vs 命令式"></a>1. <strong>开发方式：声明式 vs 命令式</strong></h3><ul>
<li><strong>SwiftUI：声明式****声明式编程</strong>是指你只需描述界面应该是什么样子，而不是描述如何一步一步地实现它。你声明界面的外观和行为，SwiftUI 会根据数据状态自动更新界面。你关注的是 <strong>“界面应如何呈现”</strong>，而不是 <strong>“如何实现这些呈现”</strong>。<strong>示例</strong>：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> counter <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;计数: <span class="subst">\(counter)</span>&quot;</span>)</span><br><span class="line">            <span class="type">Button</span>(<span class="string">&quot;增加&quot;</span>) &#123;</span><br><span class="line">                counter <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在这个例子中，<code>VStack</code>、<code>Text</code> 和 <code>Button</code> 是声明的界面元素，SwiftUI 会自动根据 <code>counter</code> 的值更新视图。</li>
<li><strong>UIKit：命令式****命令式编程</strong>要求你明确地告诉系统如何逐步完成任务。你需要手动管理视图的生命周期、布局和状态更新。你关注的是如何一步一步地 <strong>实现界面</strong>，而不仅仅是描述界面。<strong>示例</strong>：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ViewController</span>: <span class="title class_">UIViewController</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> counter <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> label <span class="operator">=</span> <span class="type">UILabel</span>()</span><br><span class="line">    <span class="keyword">let</span> button <span class="operator">=</span> <span class="type">UIButton</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">viewDidLoad</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        label.text <span class="operator">=</span> <span class="string">&quot;计数: <span class="subst">\(counter)</span>&quot;</span></span><br><span class="line">        label.frame <span class="operator">=</span> <span class="type">CGRect</span>(x: <span class="number">50</span>, y: <span class="number">100</span>, width: <span class="number">200</span>, height: <span class="number">30</span>)</span><br><span class="line">        view.addSubview(label)</span><br><span class="line"></span><br><span class="line">        button.setTitle(<span class="string">&quot;增加&quot;</span>, for: .normal)</span><br><span class="line">        button.frame <span class="operator">=</span> <span class="type">CGRect</span>(x: <span class="number">50</span>, y: <span class="number">150</span>, width: <span class="number">100</span>, height: <span class="number">50</span>)</span><br><span class="line">        button.addTarget(<span class="keyword">self</span>, action: <span class="keyword">#selector</span>(increaseCounter), for: .touchUpInside)</span><br><span class="line">        view.addSubview(button)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@objc</span> <span class="keyword">func</span> <span class="title function_">increaseCounter</span>() &#123;</span><br><span class="line">        counter <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">        label.text <span class="operator">=</span> <span class="string">&quot;计数: <span class="subst">\(counter)</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在 UIKit 中，我们需要手动管理 <code>UILabel</code> 和 <code>UIButton</code> 的状态更新和布局。</li>
</ul>
<h3 id="2-视图管理方式"><a href="#2-视图管理方式" class="headerlink" title="2. 视图管理方式"></a>2. <strong>视图管理方式</strong></h3><ul>
<li><strong>SwiftUI：自动视图更新</strong>SwiftUI 自动管理视图的更新。每当状态或数据发生变化时，SwiftUI 会自动重新渲染相应的视图。SwiftUI 使用 <strong>数据驱动</strong> 的方式，任何绑定的状态发生变化，相关的视图会自动更新。</li>
<li><strong>UIKit：手动视图更新</strong>UIKit 需要开发者手动更新视图。当数据变化时，开发者需要显式地调用方法更新视图，例如 setNeedsLayout() 或 setNeedsDisplay()，并进行手动布局。</li>
</ul>
<h3 id="3-布局和视图组件"><a href="#3-布局和视图组件" class="headerlink" title="3. 布局和视图组件"></a>3. <strong>布局和视图组件</strong></h3><ul>
<li><strong>SwiftUI：自动布局和简洁的视图组合</strong>SwiftUI 提供了多种布局组件（如 VStack、HStack、ZStack、List 等），可以让开发者简洁地组合和布局视图。SwiftUI 使用 <strong>自动布局</strong>，在布局时，你只需要告诉系统视图应如何排列，布局会自动适应不同的设备和屏幕尺寸。<strong>示例</strong>：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">VStack</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">    <span class="type">Button</span>(<span class="string">&quot;Click me&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Button clicked!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>UIKit：需要手动布局</strong>在 UIKit 中，你通常需要使用 <strong>Auto Layout</strong> 或者 <strong>frame-based layout</strong> 来设置视图的位置和大小。Auto Layout 提供了强大的约束功能，但它需要开发者明确设置约束。UIKit 中的视图布局通常更繁琐，需要开发者自己考虑如何适配不同屏幕尺寸和设备。<strong>示例</strong>：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> label <span class="operator">=</span> <span class="type">UILabel</span>()</span><br><span class="line">label.text <span class="operator">=</span> <span class="string">&quot;Hello, world!&quot;</span></span><br><span class="line">label.translatesAutoresizingMaskIntoConstraints <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">view.addSubview(label)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> button <span class="operator">=</span> <span class="type">UIButton</span>()</span><br><span class="line">button.setTitle(<span class="string">&quot;Click me&quot;</span>, for: .normal)</span><br><span class="line">button.translatesAutoresizingMaskIntoConstraints <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">view.addSubview(button)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置Auto Layout约束</span></span><br><span class="line"><span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">    label.centerXAnchor.constraint(equalTo: view.centerXAnchor),</span><br><span class="line">    label.centerYAnchor.constraint(equalTo: view.centerYAnchor),</span><br><span class="line">    button.centerXAnchor.constraint(equalTo: view.centerXAnchor),</span><br><span class="line">    button.topAnchor.constraint(equalTo: label.bottomAnchor, constant: <span class="number">20</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-状态管理"><a href="#4-状态管理" class="headerlink" title="4. 状态管理"></a>4. <strong>状态管理</strong></h3><ul>
<li><strong>SwiftUI：内建的状态管理</strong>SwiftUI 提供了很多内建的状态管理工具，如 @State、@Binding、@ObservedObject 和 @EnvironmentObject 等，用于响应数据变化并更新界面。状态和视图是紧密结合的，数据驱动视图更新。</li>
<li><strong>UIKit：手动状态管理</strong>UIKit 没有内建的状态管理机制。开发者需要手动管理状态，通常使用 <strong>Model-View-Controller (MVC)</strong> 或 <strong>Model-View-ViewModel (MVVM)</strong> 模式来组织数据和视图。状态变化时，开发者需要明确更新视图。</li>
</ul>
<h3 id="5-跨平台支持"><a href="#5-跨平台支持" class="headerlink" title="5. 跨平台支持"></a>5. <strong>跨平台支持</strong></h3><ul>
<li><strong>SwiftUI：跨平台支持</strong>SwiftUI 是 Apple 提供的跨平台框架，它支持多个 Apple 平台，包括 iOS、macOS、watchOS 和 tvOS。你只需要编写一次代码，就能在不同设备上运行。SwiftUI 提供了许多针对不同平台的优化，并允许你在不同平台之间共享视图代码。</li>
<li><strong>UIKit：主要针对 iOS 和 iPadOS</strong>UIKit 是一个 <strong>iOS 和 iPadOS</strong> 专用的框架，虽然它在某些其他平台上也有使用，但并不像 SwiftUI 那样具有强大的跨平台能力。</li>
</ul>
<h3 id="6-学习曲线和易用性"><a href="#6-学习曲线和易用性" class="headerlink" title="6. 学习曲线和易用性"></a>6. <strong>学习曲线和易用性</strong></h3><ul>
<li><strong>SwiftUI：简洁且现代的 API</strong>SwiftUI 提供了一个更为 <strong>简洁</strong> 和 <strong>现代化</strong> 的 API。因为是声明式的编程风格，开发者可以更直观地理解代码的功能，降低了学习的难度。在 SwiftUI 中，布局和视图组合更加直观和灵活，很多常见的功能和组件都是预设好的，可以快速构建界面。</li>
<li><strong>UIKit：更复杂的 API</strong>UIKit 是一个 <strong>命令式</strong> 的框架，学习曲线较陡峭，尤其是当涉及到手动管理视图更新、布局和状态时。虽然 UIKit 非常强大且灵活，但由于其 <strong>复杂性</strong>，开发者需要手动控制视图生命周期、布局和视图更新。</li>
</ul>
<h3 id="7-性能"><a href="#7-性能" class="headerlink" title="7. 性能"></a>7. <strong>性能</strong></h3><ul>
<li><strong>SwiftUI：性能优化</strong>SwiftUI 在性能上做了很多优化。由于它是声明式的，SwiftUI 能够只重新渲染视图中需要更新的部分，这样能减少不必要的重绘和性能开销。但是，由于 SwiftUI 相对较新，某些复杂的视图层级或特定的自定义行为可能会导致性能问题（需要进一步优化）。</li>
<li><strong>UIKit：成熟且稳定</strong>UIKit 已经存在多年，经过了充分的优化，性能非常稳定。在处理复杂界面和大型应用时，UIKit 更加成熟和可预测。UIKit 的手动管理机制使得开发者能更精确地控制性能，尤其是在性能要求非常高的场景下。</li>
</ul>
<h3 id="8-代码示例比较"><a href="#8-代码示例比较" class="headerlink" title="8. 代码示例比较"></a>8. <strong>代码示例比较</strong></h3><ul>
<li><strong>SwiftUI 示例</strong>：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> isToggled <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(isToggled <span class="operator">?</span> <span class="string">&quot;开&quot;</span> : <span class="string">&quot;关&quot;</span>)</span><br><span class="line">            <span class="type">Toggle</span>(<span class="string">&quot;开关&quot;</span>, isOn: <span class="variable">$isToggled</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>UIKit 示例</strong>：<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ViewController</span>: <span class="title class_">UIViewController</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> isToggled <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> label <span class="operator">=</span> <span class="type">UILabel</span>()</span><br><span class="line">    <span class="keyword">let</span> toggle <span class="operator">=</span> <span class="type">UISwitch</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">viewDidLoad</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        label.frame <span class="operator">=</span> <span class="type">CGRect</span>(x: <span class="number">50</span>, y: <span class="number">100</span>, width: <span class="number">200</span>, height: <span class="number">30</span>)</span><br><span class="line">        toggle.frame <span class="operator">=</span> <span class="type">CGRect</span>(x: <span class="number">50</span>, y: <span class="number">150</span>, width: <span class="number">100</span>, height: <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">        toggle.addTarget(<span class="keyword">self</span>, action: <span class="keyword">#selector</span>(toggleChanged), for: .valueChanged)</span><br><span class="line">        view.addSubview(label)</span><br><span class="line">        view.addSubview(toggle)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@objc</span> <span class="keyword">func</span> <span class="title function_">toggleChanged</span>() &#123;</span><br><span class="line">        isToggled <span class="operator">=</span> toggle.isOn</span><br><span class="line">        label.text <span class="operator">=</span> isToggled <span class="operator">?</span> <span class="string">&quot;开&quot;</span> : <span class="string">&quot;关&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>| 特性 | <strong>SwiftUI</strong> | <strong>UIKit</strong></p>
<h1 id="一个UIKit-需要开发者手动更新视图的代码案例"><a href="#一个UIKit-需要开发者手动更新视图的代码案例" class="headerlink" title="一个UIKit 需要开发者手动更新视图的代码案例"></a>一个UIKit 需要开发者手动更新视图的代码案例</h1><p> 在 UIKit 中，开发者需要手动更新视图，当数据或状态发生变化时，视图的更新并不会自动触发。为了展示这一点，以下是一个简单的示例，展示了如何在数据变化时手动更新视图。</p>
<h3 id="示例场景"><a href="#示例场景" class="headerlink" title="示例场景"></a>示例场景</h3><p>假设我们有一个计数器应用，显示一个标签 (<code>UILabel</code>) 和一个按钮 (<code>UIButton</code>)。每次按钮点击时，计数器会增加，并更新标签显示的文本。</p>
<h3 id="1-创建-ViewController"><a href="#1-创建-ViewController" class="headerlink" title="1. 创建 ViewController"></a>1. <strong>创建 ViewController</strong></h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ViewController</span>: <span class="title class_">UIViewController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义计数器和 UI 元素</span></span><br><span class="line">    <span class="keyword">var</span> counter <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> label <span class="operator">=</span> <span class="type">UILabel</span>()</span><br><span class="line">    <span class="keyword">let</span> button <span class="operator">=</span> <span class="type">UIButton</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">viewDidLoad</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 label</span></span><br><span class="line">        label.text <span class="operator">=</span> <span class="string">&quot;计数: <span class="subst">\(counter)</span>&quot;</span></span><br><span class="line">        label.frame <span class="operator">=</span> <span class="type">CGRect</span>(x: <span class="number">50</span>, y: <span class="number">100</span>, width: <span class="number">200</span>, height: <span class="number">30</span>)</span><br><span class="line">        view.addSubview(label)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 button</span></span><br><span class="line">        button.setTitle(<span class="string">&quot;增加&quot;</span>, for: .normal)</span><br><span class="line">        button.backgroundColor <span class="operator">=</span> .blue</span><br><span class="line">        button.frame <span class="operator">=</span> <span class="type">CGRect</span>(x: <span class="number">50</span>, y: <span class="number">150</span>, width: <span class="number">100</span>, height: <span class="number">50</span>)</span><br><span class="line">        button.addTarget(<span class="keyword">self</span>, action: <span class="keyword">#selector</span>(increaseCounter), for: .touchUpInside)</span><br><span class="line">        view.addSubview(button)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按钮点击时触发的函数</span></span><br><span class="line">    <span class="keyword">@objc</span> <span class="keyword">func</span> <span class="title function_">increaseCounter</span>() &#123;</span><br><span class="line">        counter <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 手动更新 UI 元素</span></span><br><span class="line">        label.text <span class="operator">=</span> <span class="string">&quot;计数: <span class="subst">\(counter)</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-解释"><a href="#2-解释" class="headerlink" title="2. 解释"></a>2. <strong>解释</strong></h3><p>在这个示例中，我们有以下几个关键点：</p>
<ul>
<li><strong>初始化 UI 元素</strong>：我们在 viewDidLoad 方法中创建了一个 UILabel 和一个 UIButton，并设置它们的布局和初始状态。</li>
<li><strong>按钮的事件处理</strong>：我们使用 addTarget 方法为按钮添加了点击事件，当按钮被点击时，触发 increaseCounter 方法。</li>
<li><strong>手动更新 UI</strong>：当 counter 变量增加时，我们 <strong>手动更新</strong> 标签的文本内容 label.text &#x3D; “计数: (counter)”，这是 UIKit 中更新视图的一种常见做法。并没有像 SwiftUI 中那样自动关联数据和视图更新，开发者需要手动触发视图更新。</li>
</ul>
<h3 id="3-手动更新的关键"><a href="#3-手动更新的关键" class="headerlink" title="3. 手动更新的关键"></a>3. <strong>手动更新的关键</strong></h3><p>在 UIKit 中，<strong>数据和视图之间没有自动绑定</strong>，开发者需要手动管理它们之间的关系。当数据（比如 <code>counter</code>）变化时，我们需要手动更新视图（例如更新 <code>UILabel</code> 的文本）。如果我们没有手动更新视图，界面就不会反映数据的变化。</p>
<p>在 SwiftUI 中，这个过程会更加自动化，因为 SwiftUI 使用声明式编程和数据绑定。当数据改变时，相关的视图会自动重新渲染。</p>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>UIKit 中的视图更新是 <strong>手动的</strong>，每当数据发生变化时，你需要显式地调用更新视图的代码，比如通过修改控件的属性、调用 <code>setNeedsLayout()</code> 或 <code>setNeedsDisplay()</code> 来请求重新布局或重绘。而在 SwiftUI 中，数据的变化会自动驱动视图更新。</p>
<h1 id="想学习swiftui有关数据流动的知识，需要的资料"><a href="#想学习swiftui有关数据流动的知识，需要的资料" class="headerlink" title="想学习swiftui有关数据流动的知识，需要的资料"></a>想学习swiftui有关数据流动的知识，需要的资料</h1><p> 学习 SwiftUI 中的数据流动是掌握该框架的核心技能之一，特别是如何通过各种属性包装器（如 <code>@State</code>、<code>@Binding</code>、<code>@ObservedObject</code>、<code>@EnvironmentObject</code>）来管理和传递数据。以下是一些可以帮助你深入理解 SwiftUI 数据流动的资料来源和学习途径：</p>
<h3 id="1-官方文档和教程"><a href="#1-官方文档和教程" class="headerlink" title="1. 官方文档和教程"></a>1. <strong>官方文档和教程</strong></h3><ul>
<li><strong>Apple Developer Documentation</strong>Apple 的官方文档是学习 SwiftUI 的最佳资源，它详细介绍了各个属性包装器以及如何在 SwiftUI 中管理数据。<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/swiftui/">SwiftUI 官方文档</a>你可以通过官方文档了解如何使用 @State、@Binding、@ObservedObject、@EnvironmentObject 等，以及它们之间的区别和应用场景。</li>
<li><strong>SwiftUI Tutorials</strong>Apple 提供了一系列官方教程，帮助开发者从基础到高级逐步学习 SwiftUI，涵盖了数据流动、状态管理等内容。<a target="_blank" rel="noopener" href="https://developer.apple.com/tutorials/swiftui">SwiftUI Tutorials</a>这些教程通过项目示例让你理解如何在实际应用中使用这些概念。</li>
</ul>
<h3 id="2-书籍推荐"><a href="#2-书籍推荐" class="headerlink" title="2. 书籍推荐"></a>2. <strong>书籍推荐</strong></h3><ul>
<li><strong>《SwiftUI 实战（SwiftUI by Tutorials）》</strong>由 Ray Wenderlich 团队出版的教程书籍，深入探讨了 SwiftUI 和数据流的管理，适合初学者和有一定基础的开发者。书中有多个实际示例，帮助理解如何将数据绑定到视图，并通过不同的状态管理技术来更新视图。<a href="">Ray Wenderlich SwiftUI by Tutorials</a></li>
<li><strong>《SwiftUI Essentials》</strong>这是一本官方教材，深入讲解了 SwiftUI 的各个方面，包括数据流动和状态管理的核心概念。<a target="_blank" rel="noopener" href="https://books.apple.com/us/book/swiftui-essentials/id1498508263">SwiftUI Essentials (Apple Books)</a></li>
</ul>
<h3 id="3-在线教程和视频"><a href="#3-在线教程和视频" class="headerlink" title="3. 在线教程和视频"></a>3. <strong>在线教程和视频</strong></h3><ul>
<li><strong>Hacking with Swift</strong>Hacking with Swift 是一个由 Paul Hudson 创建的非常著名的教程网站，它有很多关于 SwiftUI 的教程，涵盖了数据流动、状态管理等各个方面。<a href="">Hacking with Swift SwiftUI 教程</a></li>
<li><strong>YouTube 视频教程</strong>YouTube 上有很多关于 SwiftUI 的视频教程，其中很多都是免费的，能帮助你快速上手。你可以搜索关键字 SwiftUI Data Flow 或者 SwiftUI @State @Binding 来找到与数据流动相关的视频。推荐频道：Sean Allen、CodeWithChris、Brian Advent 等。</li>
<li><strong>Udemy 和 Coursera 课程</strong>这些在线学习平台上有许多 SwiftUI 课程，讲解数据流动和状态管理的内容非常清晰。你可以搜索 SwiftUI 或 SwiftUI Data Flow，就能找到很多实用的视频教程和课程。</li>
</ul>
<h3 id="4-SwiftUI-相关博客和文章"><a href="#4-SwiftUI-相关博客和文章" class="headerlink" title="4. SwiftUI 相关博客和文章"></a>4. <strong>SwiftUI 相关博客和文章</strong></h3><ul>
<li><strong>Medium</strong>Medium 上有大量关于 SwiftUI 的优质文章，很多作者会分享自己在开发过程中的经验，尤其是如何处理数据流动和状态管理。推荐搜索关键词：SwiftUI @State @Binding, SwiftUI Data Flow, SwiftUI @ObservedObject。</li>
<li><strong>Ray Wenderlich Blog</strong>Ray Wenderlich 的博客提供了很多高质量的 SwiftUI 相关文章，特别是关于数据流和状态管理的内容。<a href="">Ray Wenderlich SwiftUI 文章</a></li>
</ul>
<h3 id="5-开发者社区和讨论组"><a href="#5-开发者社区和讨论组" class="headerlink" title="5. 开发者社区和讨论组"></a>5. <strong>开发者社区和讨论组</strong></h3><ul>
<li><strong>Stack Overflow</strong>Stack Overflow 是一个很好的资源，你可以在这里提问关于数据流动的问题，或查看其他开发者分享的解决方案。<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/tagged/swiftui">SwiftUI Data Flow 相关问题</a></li>
<li><strong>SwiftUI Slack&#x2F;Discord 群组</strong>在 Slack 或 Discord 上有很多关于 SwiftUI 的讨论组，在这些群组里，你可以和其他开发者交流，分享经验，解决问题。</li>
<li><strong>Reddit（r&#x2F;SwiftUI）</strong>在 Reddit 的 SwiftUI 版块上，有很多开发者分享他们的学习经验和问题解决方案。<a target="_blank" rel="noopener" href="https://www.reddit.com/r/SwiftUI/">Reddit SwiftUI</a></li>
</ul>
<h3 id="6-实践项目"><a href="#6-实践项目" class="headerlink" title="6. 实践项目"></a>6. <strong>实践项目</strong></h3><ul>
<li><strong>GitHub 项目</strong>GitHub 上有很多开源的 SwiftUI 项目，涉及到数据流动的各个方面。通过浏览和参与这些项目，你可以实际学习如何在不同的场景中管理数据流。<a target="_blank" rel="noopener" href="https://github.com/search?q=swiftui">SwiftUI Projects on GitHub</a></li>
<li><strong>自己动手做项目</strong>最好的学习方式之一是通过实践。在开发自己的项目时，尽量使用 SwiftUI 来管理数据流和视图状态。你可以从简单的计数器应用、待办事项应用开始，逐渐增加功能来学习数据流动的管理方式。</li>
</ul>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>要掌握 SwiftUI 中的数据流动，首先可以从 Apple 的官方文档和教程开始，了解基础的属性包装器，如 <code>@State</code>、<code>@Binding</code>、<code>@ObservedObject</code> 等的用法。接着，阅读一些经典的书籍（如《SwiftUI 实战》）和在线资源（如 Hacking with Swift 和 Medium），并通过实践来巩固这些概念。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/swift%E7%BC%96%E7%A8%8B/" rel="tag"># swift编程</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/03/02/swift%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/" rel="prev" title="swift中类的初始化">
      <i class="fa fa-chevron-left"></i> swift中类的初始化
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/03/02/swiftui%E5%B8%83%E5%B1%80%E5%8F%8Apoint/" rel="next" title="swiftui布局及point">
      swiftui布局及point <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#swift-ui%E5%B1%9E%E6%80%A7%E5%8C%85%E8%A3%B9%E5%99%A8"><span class="nav-text">swift ui属性包裹器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-State"><span class="nav-text">1. @State</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Binding"><span class="nav-text">2. @Binding</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-ObservedObject"><span class="nav-text">3. @ObservedObject</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Environment"><span class="nav-text">4. @Environment</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-EnvironmentObject"><span class="nav-text">5. @EnvironmentObject</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-Published"><span class="nav-text">6. @Published</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90%EF%BC%9A"><span class="nav-text">举个例子：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E9%97%AE%E9%A2%98"><span class="nav-text">用户问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text">代码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B7%A8%E8%A7%86%E5%9B%BE%E8%BF%9B%E8%A1%8C%E5%85%B1%E4%BA%AB%E7%9A%84%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-text">跨视图进行共享的示例代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4"><span class="nav-text">步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-text">示例代码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%88%9B%E5%BB%BA-UserSettings-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="nav-text">1. 创建 UserSettings 数据模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%88%B6%E8%A7%86%E5%9B%BE%EF%BC%9A%E6%B3%A8%E5%85%A5%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE"><span class="nav-text">2. 父视图：注入共享数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%AD%90%E8%A7%86%E5%9B%BE%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE"><span class="nav-text">3. 子视图：使用共享数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%90%AF%E5%8A%A8%E8%A7%86%E5%9B%BE"><span class="nav-text">4. 启动视图</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A"><span class="nav-text">代码解释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="nav-text">流程：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="nav-text">总结：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E9%97%AE%E9%A2%98-1"><span class="nav-text">用户问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%AE%80%E6%B4%81%E6%80%A7%E5%92%8C%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7"><span class="nav-text">1. 简洁性和可复用性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%A7%86%E5%9B%BE%E5%B5%8C%E5%A5%97%E6%B7%B1%E5%BA%A6%E6%8E%A7%E5%88%B6"><span class="nav-text">2. 视图嵌套深度控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-text">3. 性能优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%B8%83%E5%B1%80%E5%92%8C%E7%BA%A6%E6%9D%9F"><span class="nav-text">4. 布局和约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%A7%86%E5%9B%BE%E8%AE%BE%E8%AE%A1"><span class="nav-text">5. 数据驱动的视图设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%B3%A8%E6%84%8F%E9%81%BF%E5%85%8D%E7%8A%B6%E6%80%81%E6%B1%A1%E6%9F%93"><span class="nav-text">6. 注意避免状态污染</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E5%8F%AF%E8%AF%BB%E6%80%A7%E5%92%8C%E7%BB%93%E6%9E%84%E5%8C%96"><span class="nav-text">7. 可读性和结构化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-text">8. 使用视图修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%94%E7%BB%86%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B-state"><span class="nav-text">仔细解释一下@state</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9"><span class="nav-text">主要特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#State-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-text">@State 的工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E7%A4%BA%E4%BE%8B"><span class="nav-text">使用场景和示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%8C%89%E9%92%AE%E7%82%B9%E5%87%BB%E7%8A%B6%E6%80%81"><span class="nav-text">1. 按钮点击状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%96%87%E6%9C%AC%E6%A1%86%E8%BE%93%E5%85%A5%E7%8A%B6%E6%80%81"><span class="nav-text">2. 文本框输入状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%88%87%E6%8D%A2%E5%BC%80%E5%85%B3%E7%8A%B6%E6%80%81"><span class="nav-text">3. 切换开关状态</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#State-%E7%9A%84%E7%BB%91%E5%AE%9A%E4%B8%8E-Binding"><span class="nav-text">@State 的绑定与 @Binding</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#State-%E4%BD%BF%E7%94%A8%E6%97%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">@State 使用时的注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-2"><span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#binding-state-%E4%B8%8Eobservableobject-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%8C%BA%E5%88%AB"><span class="nav-text">binding state 与observableobject 的应用场景区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-State-%E2%80%94%E2%80%94-%E7%94%A8%E4%BA%8E%E5%B1%80%E9%83%A8%E8%A7%86%E5%9B%BE%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="nav-text">1. @State —— 用于局部视图状态管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Binding-%E2%80%94%E2%80%94-%E7%94%A8%E4%BA%8E%E5%9C%A8%E7%88%B6%E8%A7%86%E5%9B%BE%E4%B8%8E%E5%AD%90%E8%A7%86%E5%9B%BE%E9%97%B4%E5%85%B1%E4%BA%AB%E5%92%8C%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%8A%B6%E6%80%81"><span class="nav-text">2. @Binding —— 用于在父视图与子视图间共享和双向绑定状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-ObservedObject-%E2%80%94%E2%80%94-%E7%94%A8%E4%BA%8E%E8%B7%A8%E8%A7%86%E5%9B%BE%E5%85%B1%E4%BA%AB%E5%92%8C%E8%A7%82%E5%AF%9F%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="nav-text">3. @ObservedObject —— 用于跨视图共享和观察数据模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#State%E3%80%81-Binding-%E5%92%8C-ObservedObject-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-text">@State、@Binding 和 @ObservedObject 的对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E6%80%BB%E7%BB%93"><span class="nav-text">适用场景总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8-State%E3%80%81-Binding-%E5%92%8C-ObservedObject"><span class="nav-text">何时使用 @State、@Binding 和 @ObservedObject</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#uikit%E5%92%8Cswiftui%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">uikit和swiftui的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%BC%80%E5%8F%91%E6%96%B9%E5%BC%8F%EF%BC%9A%E5%A3%B0%E6%98%8E%E5%BC%8F-vs-%E5%91%BD%E4%BB%A4%E5%BC%8F"><span class="nav-text">1. 开发方式：声明式 vs 命令式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%A7%86%E5%9B%BE%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-text">2. 视图管理方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%B8%83%E5%B1%80%E5%92%8C%E8%A7%86%E5%9B%BE%E7%BB%84%E4%BB%B6"><span class="nav-text">3. 布局和视图组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="nav-text">4. 状态管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%94%AF%E6%8C%81"><span class="nav-text">5. 跨平台支持</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%AD%A6%E4%B9%A0%E6%9B%B2%E7%BA%BF%E5%92%8C%E6%98%93%E7%94%A8%E6%80%A7"><span class="nav-text">6. 学习曲线和易用性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E6%80%A7%E8%83%BD"><span class="nav-text">7. 性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E6%AF%94%E8%BE%83"><span class="nav-text">8. 代码示例比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-3"><span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E4%B8%AAUIKit-%E9%9C%80%E8%A6%81%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%8A%A8%E6%9B%B4%E6%96%B0%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B"><span class="nav-text">一个UIKit 需要开发者手动更新视图的代码案例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E5%9C%BA%E6%99%AF"><span class="nav-text">示例场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%88%9B%E5%BB%BA-ViewController"><span class="nav-text">1. 创建 ViewController</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%A7%A3%E9%87%8A"><span class="nav-text">2. 解释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%89%8B%E5%8A%A8%E6%9B%B4%E6%96%B0%E7%9A%84%E5%85%B3%E9%94%AE"><span class="nav-text">3. 手动更新的关键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-4"><span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%83%B3%E5%AD%A6%E4%B9%A0swiftui%E6%9C%89%E5%85%B3%E6%95%B0%E6%8D%AE%E6%B5%81%E5%8A%A8%E7%9A%84%E7%9F%A5%E8%AF%86%EF%BC%8C%E9%9C%80%E8%A6%81%E7%9A%84%E8%B5%84%E6%96%99"><span class="nav-text">想学习swiftui有关数据流动的知识，需要的资料</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%92%8C%E6%95%99%E7%A8%8B"><span class="nav-text">1. 官方文档和教程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90"><span class="nav-text">2. 书籍推荐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%9C%A8%E7%BA%BF%E6%95%99%E7%A8%8B%E5%92%8C%E8%A7%86%E9%A2%91"><span class="nav-text">3. 在线教程和视频</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-SwiftUI-%E7%9B%B8%E5%85%B3%E5%8D%9A%E5%AE%A2%E5%92%8C%E6%96%87%E7%AB%A0"><span class="nav-text">4. SwiftUI 相关博客和文章</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%BC%80%E5%8F%91%E8%80%85%E7%A4%BE%E5%8C%BA%E5%92%8C%E8%AE%A8%E8%AE%BA%E7%BB%84"><span class="nav-text">5. 开发者社区和讨论组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE"><span class="nav-text">6. 实践项目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-5"><span class="nav-text">总结</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">YiDa</p>
  <div class="site-description" itemprop="description">自古人生于世，须有一技之能；我辈既务斯业，便当专心用功；以后名扬四海，根据即在年轻。</div>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YiDa</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
